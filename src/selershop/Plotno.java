/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * Plotno.java
 *
 * Created on 2011-06-02, 19:04:32
 */
package selershop;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ByteLookupTable;
import java.awt.image.ColorConvertOp;
import java.awt.image.ColorModel;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.awt.image.LookupOp;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.image.RescaleOp;
import java.awt.image.renderable.ParameterBlock;
import javax.media.jai.Histogram;
import javax.media.jai.JAI;
import javax.media.jai.KernelJAI;
import javax.media.jai.RenderedOp;
/**
 *
 * @author Seler
 */
public class Plotno extends javax.swing.JPanel {
    File plik;
    File drugiplik;
    BufferedImage obrazek;
    BufferedImage drugiobrazek;
    int typ;
    int drugityp;
    int[] histogram = new int[256];
    int[] histogramR = new int[256];
    int[] histogramG = new int[256];
    int[] histogramB = new int[256];
    /** Creates new form Plotno */
    public Plotno() {
        obrazek = null;
        drugiobrazek = null;
        plik = null;
        drugiplik = null;
        setSize(800, 800);
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setName("Form"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    public void paint(Graphics g)
    {
        if (obrazek != null) {
            g.drawImage(obrazek, 0, 0, obrazek.getWidth(), obrazek.getHeight() , null);
        }
    }
    
    public void Otworz() throws IOException{
            JFileChooser chooser = new JFileChooser();
            FileNameExtensionFilter filtr = new FileNameExtensionFilter("Pliki *.jpg *.png","jpg", "jpeg", "png");
            chooser.setFileFilter(filtr);
            int wynik = chooser.showOpenDialog(this);        
            if (wynik == JFileChooser.APPROVE_OPTION) {
                plik = chooser.getSelectedFile();
                obrazek = ImageIO.read(plik);
                typ = obrazek.getType();
                if (plik != null) {
                    this.setSize(obrazek.getWidth(), obrazek.getHeight());
                }
            }
        repaint();
    }
    
    public void OtworzDrugi() throws IOException{
            JFileChooser chooser = new JFileChooser();
            FileNameExtensionFilter filtr = new FileNameExtensionFilter("Pliki *.jpg *.png","jpg", "jpeg", "png");
            chooser.setFileFilter(filtr);
            int wynik = chooser.showOpenDialog(this);        
            if (wynik == JFileChooser.APPROVE_OPTION) {
                drugiplik = chooser.getSelectedFile();
                drugiobrazek = ImageIO.read(drugiplik);
            }
    }
    
    public void Resetuj() throws IOException
    {
        obrazek = ImageIO.read(plik);
        repaint();
    }
    public void Zapisz() throws IOException
    {
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filtr = new FileNameExtensionFilter("Pliki *.jpg *.png","jpg", "jpeg", "png");
        chooser.setFileFilter(filtr);
        chooser.showSaveDialog(this);
        String sciezka = chooser.getSelectedFile().toString();
        if (sciezka.contains(".jpg") || sciezka.contains(".jpeg"))
            ImageIO.write(obrazek, "jpg", new File(sciezka));
        else if (sciezka.contains(".png"))
            ImageIO.write(obrazek, "png", new File(sciezka));
        else {
            switch (typ)
            {
                case 5: sciezka += ".jpg";
                        ImageIO.write(obrazek, "jpg", new File(sciezka));
                        break;
                case 6: sciezka += ".png";
                        ImageIO.write(obrazek, "png", new File(sciezka));
                        break;
            }
        }
    }
    
    public void Punkt(Float a, Float b){
        RescaleOp op = new RescaleOp(a, b, null);
        BufferedImage nowy_obrazek = new BufferedImage(obrazek.getWidth(), obrazek.getHeight(), obrazek.getType());
        op.filter(obrazek, nowy_obrazek);
        obrazek = nowy_obrazek;
        repaint();
    }
    
    public void Splot(float[] matrix, int rozmiarX, int rozmiarY)
    {
        Kernel kernel = new Kernel(rozmiarX, rozmiarY, matrix);
        ConvolveOp op = new ConvolveOp(kernel);
        BufferedImage nowy_obrazek = new BufferedImage(obrazek.getWidth(), obrazek.getHeight(), obrazek.getType());
        op.filter(obrazek, nowy_obrazek);
        obrazek = nowy_obrazek;
        repaint();
    }
    public void ObliczHistogram()
    {
        for(int i = 0; i < 256; i++){
            histogram[i] = 0;
            histogramR[i] = 0;
            histogramG[i] = 0;
            histogramB[i] = 0;
        }

        Color tempColor = null;
        for(int i = 0; i < obrazek.getHeight(); i++)
            for(int j = 0; j < obrazek.getWidth(); j++)
            {
                tempColor = new Color(obrazek.getRGB(j, i));
                //histogram[najwiekszy(tempColor.getRed(), tempColor.getGreen(), tempColor.getBlue())]++;
                histogram[(tempColor.getRed()+tempColor.getGreen()+tempColor.getBlue())/3]++; //suma na 3 = ogolna jasnosc?
                histogramR[tempColor.getRed()]++;
                histogramG[tempColor.getGreen()]++;
                histogramB[tempColor.getBlue()]++;
            }
    }
    
    private static int najwiekszy(int num1, int num2, int num3)
    {
        int najwiekszy = num1;
        if(num2 > najwiekszy)
            najwiekszy = num2;
        else if(num3 > najwiekszy)
            najwiekszy = num3;
        
        return najwiekszy;
    }
    public void wyrownanie(){
        int[] valueRed = new int[256];
        int[] valueGreen = new int[256];
        int[] valueBlue = new int[256];

        Color tempColor = null;
        for(int i = 0; i < obrazek.getHeight(); i++)
            for(int j = 0; j < obrazek.getWidth(); j++)
            {
                tempColor = new Color(obrazek.getRGB(j, i));
                valueRed[tempColor.getRed()]++;
                valueGreen[tempColor.getGreen()]++;
                valueBlue[tempColor.getBlue()]++;
            }

        int number = obrazek.getHeight() * obrazek.getWidth();

        //float[] probability = new float[256];
        float[] probabilityr = new float[256];
        float[] probabilityg = new float[256];
        float[] probabilityb = new float[256];
        for(int i = 0; i < 256; i++)
        {
            //probability[i] = (((float)value[i])/number) * 256;
            probabilityr[i] = (((float)valueRed[i])/number) * 255;
            probabilityg[i] = (((float)valueGreen[i])/number) * 255;
            probabilityb[i] = (((float)valueBlue[i])/number) * 255;
        }


        //byte[] sk = new byte[256];
        byte[] skR = new byte[256];
        byte[] skG = new byte[256];
        byte[] skB = new byte[256];

        //sk[0] = (byte)probability[0];
        skR[0] = (byte)probabilityr[0];
        skG[0] = (byte)probabilityg[0];
        skB[0] = (byte)probabilityb[0];

        for(int i = 1; i < 256; i++)
        {
            //probability[i] = probability[i-1] + probability[i];
            //sk[i] = (byte)probability[i];
            probabilityr[i] = probabilityr[i-1] + probabilityr[i];
            skR[i] = (byte)probabilityr[i];
            probabilityg[i] = probabilityg[i-1] + probabilityg[i];
            skG[i] = (byte)probabilityg[i];
            probabilityb[i] = probabilityb[i-1] + probabilityb[i];
            skB[i] = (byte)probabilityb[i];
        }
        
        byte[][] tab = { skR, skG, skB };
        LookupOp op =  new LookupOp(new ByteLookupTable(0, tab), null);
        BufferedImage nowy_obrazek = new BufferedImage(obrazek.getWidth(), obrazek.getHeight(), obrazek.getType());
        op.filter(obrazek, nowy_obrazek);
        obrazek = nowy_obrazek;
        repaint();
    }
    public void naCzarnoBialy(){
        ColorConvertOp cco = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);
        obrazek = cco.filter(obrazek, null);
    }
    public void Binaryzacja(Float prog){
        naCzarnoBialy();
        
        Histogram his = (Histogram)JAI.create("histogram", obrazek).getProperty("histogram");
        double[] threshold = his.getPTileThreshold(prog);
        
        obrazek = JAI.create("binarize", obrazek, threshold[0]).getAsBufferedImage();
        repaint();
    }
    public void Erozja(float[] macierz, int rozmiarX, int rozmiarY){
        KernelJAI kernel = new KernelJAI(rozmiarX, rozmiarY, macierz);
        
        ParameterBlock pb = new ParameterBlock();
        pb.addSource(obrazek);
        pb.add(kernel);

        RenderedImage tempRenderer = JAI.create("erode", pb);
        RenderedOp toCreate = JAI.create("filestore", tempRenderer, "png");
        obrazek =  toCreate.getAsBufferedImage();
        repaint();
    }
    public void Dylatacja(float[] macierz, int rozmiarX, int rozmiarY){
        KernelJAI kernel = new KernelJAI(rozmiarX, rozmiarY, macierz);
        
        ParameterBlock pb = new ParameterBlock();
        pb.addSource(obrazek);
        pb.add(kernel);

        RenderedImage tempRenderer = JAI.create("dilate", pb);
        RenderedOp toCreate = JAI.create("filestore", tempRenderer, "png");
        obrazek =  toCreate.getAsBufferedImage();
        repaint();
    }
    
    public void DwaObrazy(boolean operacja){
        
        ColorModel cm = obrazek.getColorModel();
        int w1 = obrazek.getWidth();
        int h1 = obrazek.getHeight();
        int w2 = drugiobrazek.getWidth();
        int h2 = drugiobrazek.getHeight();
        int width = w1;
        int height = h1;
        if (w2 < w1) width = w2;
        if (h2 < h1) height = h2;
        Color c1, c2;
        
        BufferedImage tempobraz = new BufferedImage(cm, cm.createCompatibleWritableRaster(width, height), cm.isAlphaPremultiplied(), null);

        int r=0, g=0, b=0;
        for(int i = 0; i < height; i++)
            for(int j = 0; j < width; j++){
                c1 = new Color(obrazek.getRGB(j, i));
                c2 = new Color(drugiobrazek.getRGB(j, i));
                if(operacja){
                    r = DodajKolory(c1.getRed(), c2.getRed());
                    g = DodajKolory(c1.getGreen(), c2.getGreen());
                    b = DodajKolory(c1.getBlue(), c2.getBlue());
                } else {
                    r = OdejmijKolory(c1.getRed(), c2.getRed());
                    g = OdejmijKolory(c1.getGreen(), c2.getGreen());
                    b = OdejmijKolory(c1.getBlue(), c2.getBlue());
                }
                
                tempobraz.setRGB(j, i, new Color(r,g,b,255).getRGB());
            }
        obrazek = tempobraz;
        repaint();
    }
    
    private int DodajKolory(int c1, int c2){
        int c3 = c1+c2;
        if(c3>255)c3=255;
        return c3;
    }
    private int OdejmijKolory(int c1, int c2){
        int c3 = c1-c2;
        if(c3<0)c3=0;
        return c3;
    }
    
}
